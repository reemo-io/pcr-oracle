.\" Process this file with
.\" groff -man -Tascii $FILENAME
.\"
.\"
.TH PCR-ORACLE "8" "@DATE@" "@PCR_ORACLE_VERSION@" "Predict TPM PCR values"
.SH NAME
pcr-oracle \- predict PCR values
.SH SYNOPSIS
.BR "pcr-oracle [\fIoptions\fP] \fIaction\fP ...
.\" ##################################################################
.\" # DESCRIPTION
.\" ##################################################################
.SH DESCRIPTION
This utility can be used to predict TPM PCR values at a specific time during
system boot, create a PCR policy for these values, and seal a secret to that.
.P
In simple prediction mode, \fPpcr-oracle\fP will compute expected
hash values for a subset of PCRs, and write them to standard
output. The most common use case will probably be to base the
prediction on the TPM event log that was generated by the firmware
during the most recent boot. However, there are other modes as well.
.P
In sealing mode, \fPpcr-oracle\fP will seal a given secret (such as a
LUKS device password) to either a set of PCR values, or to an authorized
PCR policy.
.\" ##################################################################
.\" # Prediction Mode
.\" ##################################################################
.SS Prediction Mode
In this mode, \fBpcr-oracle\fP is invoked like this:
.P
.nf
.in +2
# pcr-oracle --from eventlog \\
.br
        --before --stop-event grub-command=tpm2_key_protector_init \\
.br
        predict 0,2,4,7,9
.fi
.P
This would create a PCR prediction for registers 0, 2, 3, 7, and 9 by
scanning the current TPM event log until the point where grub executes
a command called \fBtpm2_key_protector_init\fP.
.P
As it processes the log, it will recompute the hash values for certain events to
match the latest changes that were made to the system. For instance, for EFI Boot
Variable events, it will consult the \fIcurrent\fP value of a EFI variable and
rehash it. The same holds for EFI Boot Service Application events for grub2 or
shim; or for EFI GPT events.
.P
In the example above, \fBpcr-oracle\fP will print the predicted values to standard
output. If you want to process these values with a tool from the tpm2.0-tools
package, you may prefer binary output, which you can select by invoking the
tool with \fB--format binary\fP.
.\" ##################################################################
.\" # PCR Policies
.\" ##################################################################
.SS PCR Policies
The standard approach for sealing a secret against an expected system state
using the TPM is to create what is called a "PCR Policy". This policy essentially
requires a given set of PCRs to contain a specific set of values. This policy can
be used to "seal" a secret, ie encrypt it using a key only the TPM has access
to.
.P
At some point, for example during the boot process, the boot loader will
attempt to unseal this sealed secret. If the TPM's PCRs contain the
expected values at this point in time, unsealing will succeed. If they
do not contain the expected values, unsealing will either fail, or
produce gibberish.
.P
In order to seal a secret againt a predicted set of PCRs, one would typically
invoke \fBpcr-oracle\fP like this:
.P
.nf
.in +2
# pcr-oracle --from eventlog \\
.br
        --before --stop-event grub-command=tpm2_key_protector_init \\
.br
        --input secret --output sealed \\
.br
        seal-secret 0,2,4,7,9
.fi
.P
Note that the size of the secret to be sealed must not exceed 128 bytes.
.P
The reverse operation looks like this:
.P
.nf
.in +2
# pcr-oracle --input sealed --output recovered \\
        unseal-secret 0,2,4,7,9
.fi
.P
This will instruct the TPM to unseal the given sealed data, computing the
policy hash using the current values of the indicated PCRs.
.P
.\" ##################################################################
.\" # Authorized Policies
.\" ##################################################################
.SS Using Authorized Policies
While regular PCR policies are sound and simple, they are not very flexible, unfortunately.
For example, transparently handling updates of the boot loader is rather
difficult because we would first have to retrieve the secret before we're able
to re-seal it to the future set of PCR values. This is where Authorized
Policies come in.
.P
TPM Authorized Policies provide a mechanism by which a secret is not sealed
to a set of specific PCR values, but to a list of PCR indices, and a public
RSA key. This combination (PCR indices and public key) is called an
Authorized Policy.
.P
The owner of the system can then use the secret RSA key to "authorize"
a specific set of PCR values, which is in essence a digital signature.
.P
When unsealing the secret during system boot, the boot loader would
present the TPM with the original Authorized Policy, and the signed set
of PCR values. The TPM then essentially compares the current set of PCR
values (as selected by the policy) to the authorized set of values, and
verify the authorization's signature using the public key from the
policy. If the PCR values match, and the signature checks out, it will
be able to unseal the secret.
.P
The benefit of this approach is that you can now seal the secret (such as
a LUKS password) once - and when we later update the boot loader, shim
loader etc, we just have to authorize the new set of PCR values using the
RSA secret key.
.P
So here's an example sequence of commands to use an authorized policy:
.P
.nf
.in +2
# pcr-oracle \\
.br
        --private-key policy-key.pem \\
.br
        --auth authorized.policy \\
.br
        create-authorized-policy 0,2,4,7,9
.br
# pcr-oracle \\
.br
        --auth authorized.policy \\
.br
        --input file-containing-secret \\
.br
        --output sealed-secret \\
.br
        seal-secret
.br
# pcr-oracle \\
.br
        --private-key policy-key.pem \\
.br
        --from eventlog \\
.br
        --before --stop-event grub-command=tpm2_key_protector_init \\
.br
        --output signed.policy \\
.br
        sign 0,2,4,7,9
.br
.fi
.P
The first of these commands creates the authorized policy and writes it
to a file named \fPauthorized.policy\fP. This file, along with the public
portion of the RSA key, needs to be stored somewhere in a location that
is accessible at the time we need to unlock the LUKS key.
.P
The second command seals the secret against this policy. The clear text
is stored in \fPfile-containing-secret\fP, the sealed cipher text is
stored in \fBsealed-secret\fP. Note that the TPM is limited in the maximum
amount of secret data it can seal; it's probably safe to assume a limit of
128 bytes.
.P
Finally, the third command using the prediction logic of \fBpcr-oracle\fP
to predict a specific set of PCR values, in exactly the same way described
in the section above on prediction mode. It then uses the given RSA key
to sign these values and store the result in \fBsigned.policy\fP.
.P
Depending on the boot loader used, it may be helpful to provide the
public portion of the RSA key in a format that is trivial to handle. For
instance, it would be overkill to add DER parsing of RSA keys to grub.
In a case like that, you want the key to be available in a form that
can be fed to the TPM chip more or less directly. \fBpcr-oracle\fP
supports this via its \fBstore-public-key\fP subcommand:
.P
.nf
.in +2
# pcr-oracle \\
.br
        --private-key policy-key.pem \\
.br
        --public-key policy-pubkey \\
.br
        store-public-key
.fi
.P
This command will read the RSA private key from the PEM file,
and write the public key as a \fBTPM2B_PUBLIC\fP object to
the indicated output file \fBpolicy-pubkey\fP.
.P
Alternatively, if you want the public key to be stored as PEM formatted
key, simply specify the file name of the public key with a \fB.pem\fP
extension:
.P
.nf
.in +2
# pcr-oracle \\
.br
        --private-key policy-key.pem \\
.br
        --public-key policy-pubkey.pem \\
.br
        store-public-key
.fi
.P
For details, please see section \fBRSA Key File Formats\fP.
.\" ##################################################################
.\" # Supporting different key file format
.\" ##################################################################
.SS RSA Key File Formats
By default, \fBpcr-oracle\fP stores private RSA keys as PEM files and
public RSA keys in native TPM encoded format. This behavior can be tuned,
however. When it detects a file name that has a \fB.pem\fP extension, it
will automatically assume that the caller expects the file to be in PEM
format.
.P
In addition, you can explicitly force a specific file format by
prefixing the entire path by either \fBpem:\fP opr \fBnative:\fP,
respectively.
.\" ##################################################################
.\" # New policy file format
.\" ##################################################################
.SS Using the TPM2.0 policy file format
By default, \fBpcr-oracle\fP writes the policy and key files (which are
supposed to be consumed by the boot loader) in a raw format that can be
loaded more or less directly into the TPM.
.P
The upstream grub community has adopted a more versatile (and complex) file
format, which combines key and policies into a single, ASN.1 encoded file.
The behavior can be selected by invoking the \fBsign\fP, \fBseal-secret\fP
and \fBunseal-secret\fP operations with the \fB--key-format=tpm2.0\fP
option. For examples, please see the \fBEXAMPLES\fP section below.
.P
Optionally, \fBpcr-oracle\fP can create \fBJSON\fP files compatible
with the \fBsystemd-cryptenroll\fP tool when signing a policy.  The
generated document will contain a grouped list by hash algorithms
(sha256 by default) of the different possible valid signed policies
that the systemd-cryptsetup can recognize during boot time.  Each
entry will contain the list of PCRs that compose the PCR policy, a
hash of the public key, the hash of the policy and the signature (in
base64) of the PCR policy.  This document is generated with the
\fB--policy-format systemd\fP parameter.
.\" ##################################################################
.\" # Test Cases
.\" ##################################################################
.SS Creating and Replaying Test Cases
Firmwares tend to be buggy, like every piece of code, and UEFI firmwares
are no different. In order to create a broad base of test cases to
validate \fBpcr-oracle\fP against, it comes with support for creating
and replaying test cases.
.P
A test case is mostly a dump of the data that \fBpcr-oracle\fP processes
when re-hashing the events from the TPM event log. This includes
the content of UEFI variables such as Boot entries, variables related
to Secure Boot, GPT headers, full copies of any EFI Applications loaded
during bootup (such as \fBshim.efi\fP, \fBgrub.efi\fP), and hashes
for other files loaded by the boot loader (such as \fBgrub.cfg\fP, or
the kernel and initrd).
.P
The following command will create a test case and store it in a
directory tree at \fB/tmp/pcr-oracle.test\fP:
.P
.nf
.in +2
# pcr-oracle --from eventlog --verify current -d \\
.br
        --create-testcase /tmp/pcr-oracle.test \\
.br
        predict all
.fi
.P
If you want to submit your test case, please use \fBtar\fP to archive
the test case and create an issue in the github issue tracker at
\fBgithub.com/okirch/pcr-oracle\fP.
.P
To replay a test case, you can do this:
.P
.nf
.in +2
# pcr-oracle --from eventlog --verify current -d \\
.br
        --replay-testcase /tmp/pcr-oracle.test \\
.br
        predict all
.fi
.P
.\" ##################################################################
.\" # Self-test
.\" ##################################################################
.SS TPM Self-test
To perform a TPM self-test, simply execute \fBpcr-oracle\fP like this:
.P
.nf
.in +2
# pcr-oracle self-test
.fi
.P
The reason this subcommand exists is that it allows an installer to
set up full disk encryption without having to pull in all of tpm-tools.
.\" ##################################################################
.\" # RSA key size test
.\" ##################################################################
.SS TPM RSA key size test
To perform a TPM RSA key size test, simply execute \fBpcr-oracle\fP like
this:
.P
.nf
.in +2
# pcr-oracle --rsa-bits 2048 rsa-test
.fi
.P
This subcommand allows the external programs, such as fde-tools, to find
out the largest supported RSA key size.
.\" ##################################################################
.\" # OPTIONS
.\" ##################################################################
.SH OPTIONS
.TP
.BI --from " source
In prediction mode, specify a source from which to initialize the PCRs. This
can be one of
.BR eventlog ,
.BR current ", or
.BR zero .
.IP
With \fBeventlog\fP, the tool scans the TPM event log and re-compute
the event hashes based on the current state of the system.
.IP
Specifying a source of \fBzero\fP will start prediction with all PCRs cleared.
Specifying a source of \fBcurrent\fP will start prediction with all PCRs
set to the current values of the system's TPM.
.TP
.BI --algorithm " hash-alg
By default, \fBpcr-oracle\fP will operate on PCR registers that use  the
sha256 hash algorithm. Using this option, you can select a different hash
algorithm, assuming the chip supports it.
For backward compatibility with version 1 of the specification, all TPMv2
chips also support sha1, but using that is not recommended.
.TP
.BI --format " fmt
In prediction mode, \fBpcr-oracle\fP will write the predicted PCR values
to standard output in a human readable format. Using this option, you can
select different output formats.
.IP
A format of \fBbinary\fP will write the predicted values as a binary octet
stream, all values concatenated together. This format can be used with
tools like
.BR tpm2_policypcr (1). A format of \fBtpm2-tools\fP will use a reporting
format this is similar to the one that the tpm2-tools produce as output.
The default behavior is selected by format \fBplain\fP.
.TP
.BI --stop-event " event-desc
Specify at which point to stop processing the TPM event log, and report
the predicted PCR values. The format of \fIevent-desc\fP is an event type,
followed by a \fB=\fP, followed by a string argument.
.IP
Currently, only two event types are supported, \fBgrub-command\fP and
\fBgrub-file\fP. These correspond to the IPL event emitted by grub
when executing a command, or reading a file, respectively.
.IP
For a grub command event, the string argument is the name of the command,
without any arguments. For a grub file event, the string argument is
a file name or a (partial) file path. Path tail matching is performed,
i.e. an event for reading \fBEFI/BOOT/grub.cfg\fP can be matched by specifying
a stop event for \fBgrub.cfg\fP, \fBBOOT/grub.cfg\fP, or \fBEFI/BOOT/grub.cfg\fP,
respectively.
.TP
.BI --before
When a stop event has been given, report predicted PCR values \fIbefore\fP
processing the event. This is the default behavior.
.TP
.BI --after
When a stop event has been given, report predicted PCR values \fIafter\fP
processing the event. This may be useful, for example, if you don't
measure grub's command events (tracked in PCR8) but only its file load
events (tracked in PCR9). In this case, it would be totally sufficient
to stop processing after grub loaded \fPgrub.cfg\fP from the EFI
System Partition.
.TP
.BI --authorized-policy " path
Specify the location of the authorized policy. In conjunction with
the \fBcreate-authorized-policy\fP action, the newly created policy
is written to this location. For subsequent actions, such as \fBseal\fB,
the policy will be read from this location.
.TP
.BI --private-key " path
Specify the RSA secret key to be used with authorized policies.
For notes on the file format, please see section \fBRSA Key File Formats\fP.
.TP
.BI --public-key " path
Specify an RSA public key to be used with authorized policies.
For notes on the file format, please see section \fBRSA Key File Formats\fP.
.TP
.BI --rsa-generate-key
When used while creating an authorized policy, a sign or when storing
the public key, this will generate the RSA private key "on the
fly". This should not be different from what \fBopenssl genrsa\fP
does; the only reason this switch exists is that it may save you from
increasing the footprint of your installed system (by not having to
install the openssl command line utilities, for example).
.TP
.BI --rsa-bits " bits
By default, RSA 2048 is used as the algorithm to create the public and
private key and configure the storage root key(SRK) in TPM. This option
allows the user to specify the larger RSA key size. The supported key
sizes are: 2048, 3072, and 4096 bits.
.TP
.BI --tpm-eventlog " path
By default, the tool will read the current TPM event log. It is possible
to process an event log generated on a different system by specifying it
with this option.
.TP
.BI --key-format " fmt
By default, the tool writes all data that is supposed to be read by the boot
loader in a raw format that requires little or no conversion before
being loaded into the TPM. This format can be requested explicitly by
using \fB--key-format=raw\fP.
.IP
Alternatively, it can read and write a format called \fBtpm2.0\fP which
is becoming the preferred format used by grub.
.TP
.BI --policy-name " name
For the tpm2.0 format, there is an extra field, Name, for the authorized
polices. This option is only valid when sigining the sealed key in
\fBtpm2.0\fP format. The \fBName\fP is optional and only used for display
purposes. If the user doesn't specify a name, the default name is 'default'.

.\" ##################################################################
.\" # NOTES
.\" ##################################################################
.SH NOTES
\fBpcr-oracle\fP also supports an \fBunseal\fP action for unsealing
secrets. This is mostly for testing purposes and may change at any
time.
.\" ##################################################################
.\" # EXAMPLES
.\" ##################################################################
.SH EXAMPLES
The following will seal a secret against PCR 0,2,4,7, and write the result
to \fBsealed-pcr.tpm\fP using the new tpm2.0 format:
.P
.nf
.in +2
# pcr-oracle \\
	--key-format=tpm2.0 \\
	--input secret \\
	--output sealed-pcr.tpm \\
	seal-secret 0,2,4,7
.fi
.P
To seal a secret for an authorized policy:
.P
.nf
.in +2
# pcr-oracle \\
	--key-format=tpm2.0 \\
	--auth authorized.policy \\
	--input secret \\
	--output sealed-auth.tpm \\
	seal-secret
.fi
.P
To sign the policy against PCR 0,2,4,7 for sealed-auth.tpm:
.P
.nf
.in +2
# pcr-oracle \\
	--key-format=tpm2.0 \\
	--policy-name "sealing test" \\
	--private-key policy-key.pem \\
	--input sealed-auth.tpm \\
	--output sealed-auth-signed.tpm \\
	sign 0,2,4,7
.fi
.P
To generate a signed policy compatible with systemd:
.P
.nf
.in +2
# pcr-oracle \\
	--private-key policy-key.pem \\
	--from eventlog \\
	--output tpm2-pcr-signature.json \\
	--policy-format systemd \\
	sign 0,2,4,7
.fi
.P
This can be registered with:
.P
.nf
.in +2
# systemd-cryptenroll \\
	--tpm2-device=auto \\
	--tpm2-public-key=public-key.pem \\
	--tpm2-public-key-pcrs="0,2,4,7" \
	--tpm2-signature=tpm2-pcr-signature.json \\
	--policy-format systemd \\
	/dev/sda3
.fi
.\" ##################################################################
.\" # SEE ALSO
.\" ##################################################################
.SH SEE ALSO
.BR tpm2_policypcr (1),
.BR tpm2_policyauthorize (1),
.BR tpm2_create (1).
.SH AUTHOR
\fBpcr-oracle\fP was written by Olaf Kirch.
